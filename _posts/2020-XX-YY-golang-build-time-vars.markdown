---
layout: post
title:  Injec build-time variabtles in Go.
date:   2020-XX-YY
author: Paschalis Ts
tags:   []
mathjax: false
description: ""
---

The [Go Linker](https://golang.org/cmd/link/) supports injecting variable values during your builds.

```
-X importpath.name=value
	Set the value of the string variable in importpath named name to value.
	This is only effective if the variable is declared in the source code either uninitialized
	or initialized to a constant string expression. -X will not work if the initializer makes
	a function call or refers to other variables.
```

When using `go build` you can pass arguments to the linker using `-ldflags`

```
-ldflags '[pattern=]arg list'
		arguments to pass on each go tool link invocation.
```

and this means we can access both main and package variables by using

```bash
go build -ldflags="-X 'main.var_name=value'"
go build -ldflags="-X 'mypackage.var_name=value'"
```

The variable we're setting can be either exported or unexported, initialized or not, but it won't work for constants or variables who are initialized using a function call.

This enables some interesting functionality for our Go builds!

## An example

I'm using the following structure (too lazy to set up Go modules, sorry)
```
$GOPATH
|
├── base/
|   ├── main.go
|   └── build
|       └── build.go
```

```go
package build

var Environment, Commit, User, Datetime string
```

```go
package main

import (
    "fmt"
    "base/build"
)
var Version = "noVersion"

func main() {
    fmt.Println("Version:\t", Version)
    fmt.Println("build.Environment:\t", build.Environment)
    fmt.Println("build.Commit:\t", build.Commit)
    fmt.Println("build.User:\t", build.User)
    fmt.Println("build.Datetime:\t", build.Datetime)
}
```

We can now build our code with this new feature!

```bash
go build -ldflags "-X 'main.Version=v0.0.1' \
-X 'base/build.Environment=linux' \
-X 'base/build.Datetime=$(date -u)' \
-X 'base/build.Commit=$(git rev-parse --short HEAD)' \
-X 'base/build.User=$(id -u -n)'"

$ ./base
Version:	 v0.0.1
build.Environment:	 linux
build.Commit:	 918ec66
build.User:	 paschalistsilias
build.Datetime:	 Fri Jan 17 09:35:20 UTC 2020
```

## Investigate set variables
The `nm` command in `go tool` *lists the symbols defined or used by an object file, archive, or executable*.

If we run it on our `base` executable, we'll see the variables that have been set, along with their addresses. The 'D' and 'R' stand for 'data segment symbol' and 'read-only data segment symbol'. This can help debug if your executable actually contains a specific variable.
```
$ go tool nm base | grep build
 1170a50 D base/build.Commit
 10eba00 R base/build.Commit.str
 1170a60 D base/build.Datetime
 10eb280 R base/build.Datetime.str
 1170a70 D base/build.Environment
 10e9430 R base/build.Environment.str
 1170a80 D base/build.User
 10e9f80 R base/build.User.str
 1001000 T go.buildid
 1170b50 D runtime.buildVersion       <--- runtime.Version()
```

The `nm` allows you to check on some other variables set by default, eg. the very last line is what's being used in runtime.buildVersion, which is generated by [`go tool dist`](https://github.com/golang/go/blob/574c286607015297e35b7c02c793038fd827e59b/src/cmd/dist/build.go#L340).



## Use cases

We can use this feature when building our docker images.

```Dockerfile
RUN LATEST_COMMIT=$(git rev-parse HEAD -1 HEAD)
RUN go build -ldflags "-X main.GitCommit=$LATEST_COMMIT"

# If you're using Docker >= 18.09, there are some pre-set ARG variables available
ARG TARGETPLATFORM
ARG TARGETARCH
RUN go build -ldflags "-X 'main.targetPlatform=$TARGETPLATFORM' -X 'main.targetArch=$TARGETARCH'"
```

We can use this feature in Jenkins

```Jenkinsfile
stage('Build'){
    echo 'Building Executable'

    def now = new Date().format("yyMMdd.HHmm", TimeZone.getTimeZone('UTC'))

    sh """cd /path/to/project/ && go build -ldflags 'X main.BuildDate=$now'"""
}
```

Use Environment variables

In Github Actions

It can be used to vendor dependencies,



Of course, much of this is against the spirit of *reproducible builds*, which is something I'm working on to write more about!